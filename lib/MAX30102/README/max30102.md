## API for MAX3010X sensors
This api has been written for the MAX30102 sensor in specific but works with every MAX3010X sensor.


## How does `bool max30102_i2c_read_multiled_data_burst(struct i2c_device *device)` work?

This function performs a **burst read** of the MAX30102 FIFO when the sensor is configured in **Multi-LED mode** with **two slots** (RED + IR). It returns **true** only when the IR buffer is full so that the hr-logic can calculate the number of beats in that sample (MAX30102_BPM_SAMPLES_SIZE).

### 1) Read FIFO pointers (WR_PTR and RD_PTR)
The MAX30102 FIFO is a circular buffer. The chip exposes two 5-bit pointers:

- **WR_PTR** (`MAX30102_FIFO_WR_PTR_ADDR`): where the sensor will write the next sample
- **RD_PTR** (`MAX30102_FIFO_RD_PTR_ADDR`): where the host will read the next sample


### 2) Compute how many samples are pending
The number of unread samples is computed using the pointers in modulo-32 arithmetic:

```c
int num_samples = (wr_ptr - rd_ptr) & 0x1F;
```

- `& 0x1F` ensures wrap-around on a 32-deep FIFO (5 bits).
- If `num_samples == 0`, there is nothing to read → the function returns `false`.

### 3) Convert samples to bytes to read
Each sample is **6 bytes** total:

- **3 bytes RED** (24-bit, but only 18 bits are valid)
- **3 bytes IR**  (24-bit, but only 18 bits are valid)

- the number of valid bits id dependent on MAX30102_SPO2_RANGE_4096 and MAX30102_SPO2_LED_PW_411

So:

```c
int bytes_to_read = num_samples * 6;
```

A temporary buffer (`fifo_buffer[192]`) is used, and `bytes_to_read` is capped for safety.

### 4) Perform the FIFO burst read
To read from FIFO you must address `FIFO_DATA` (`MAX30102_FIFO_DATA_ADDR`). The code does it in two steps:

1. **Transmit** the FIFO register address to set the internal pointer:

```c
i2c_master_transmit(..., &fifo_data_addr, 1, ...)
```

2. **Receive** `bytes_to_read` bytes in one shot:

```c
i2c_master_receive(..., fifo_buffer, bytes_to_read, ...)
```

This is the key idea: instead of reading sample-by-sample, it reads the whole pending FIFO chunk with a single I2C burst.

This is better than performing an i2c_master_receive for every sample (6 bytes). making to many receives events saturates the i2c buffers (this is a problem I had before).

### 5) Decode RED/IR 18-bit values
For each sample `i`, the function extracts 6 bytes:

- `base = i * 6`
- builds two 24-bit values:

```c
uint32_t red = (b0<<16) | (b1<<8) | b2;
uint32_t ir  = (b3<<16) | (b4<<8) | b5;
```

Then it masks them to **18 bits** as per the MAX3010x datasheet:

```c
red &= 0x3FFFF;
ir  &= 0x3FFFF;
```

### 6) Push into ring buffers (RAW + AC) and decide the return value
The samples are fed into internal buffers:

- `RED_buffer[]`, `IR_buffer[]` (RAW)
- `RED_ac_buffer[]`, `IR_ac_buffer[]` (AC component extracted via `get_RED_AC()` / `get_IR_AC()`)

- In this current implementation the RED_buffer data is not used for that there's no Spo2 calculation so it is not needed.

The helper functions update a circular index and may signal that a full window has been collected.

In this implementation, the **return value depends on the IR path**:

- `if (update_ir_buffers(ir)) return true;`

So the function returns:

- **true** → when the IR ring buffer has reached the end of a window (i.e., enough samples for BPM)
- **false** → otherwise, or when there were no new FIFO samples, or on I2C errors

A `taskYIELD()` is executed inside the loop to avoid starving other tasks when a lot of samples are pending. This was put to mitigate the error of the watchdog timer.

## other functions

The other function are used to set the register of the sensor in the initialization/configuration phase and to reset those registers.


