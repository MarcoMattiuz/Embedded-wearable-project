```c
./lib/_mpu6050/include/mpu6050.h 
./lib/_mpu6050/src/mpu6050.c
```
# Types
```c
typedef struct {
    int16_t a_x;
    int16_t a_y;
    int16_t a_z;
} Raw_Data_acc;

typedef struct {
    int16_t g_x;
    int16_t g_y;
    int16_t g_z;
} Raw_Data_gyro;

typedef struct {
    float a_x;
    float a_y;
    float a_z;
} ACC_Three_Axis_t; // m/s²

typedef struct {
    float g_x;
    float g_y;
    float g_z;
} GYRO_Three_Axis_t; // °/s

typedef struct {
    float a_x_sum;
    float a_y_sum;
    float a_z_sum;
} ACC_accumulated;

typedef struct {
    float g_x_sum;
    float g_y_sum;
    float g_z_sum;
} GYRO_accumulated;

static float accel_bias[3]  = {0.0f, 0.0f, 0.0f};
static float gyro_bias[3]   = {0.0f, 0.0f, 0.0f};
```
# Code Explanation

This document explains how the MPU6050 driver works. It focuses on:

* sensor's register configuration
* sensor's FIFO usage
* raw data acquisition from FIFO
* conversion to physical units

---

## Sensor's Register Configuration
```c
esp_err_t mpu6050_init();
```

This function fully configures the MPU6050 by writing to its internal registers.

### Sensor Wake-up

```c
/*
 * PWR_MGMT_1 register (0x6B)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
 *             ^   ^   ^       ^   ^   ^   ^
 *             |   |   |       |   |___|___| CLKSEL
 *             |   |   |       |       000 = Internal 8 MHz oscillator
 *             |   |   |       +-- TEMP_DIS (1 = temperature sensor disabled)
 *             |   |   +---------- CYCLE (low power cycle mode)
 *             |   +-------------- SLEEP (1 = sleep mode)
 *             +------------------ DEVICE_RESET (1 = reset all registers)
 */
cmd[0] = MPU6050_REG_PWR_MGMT_1;
cmd[1] = 0x00;   
```

Wake up the sensor.

---

### Sample Rate Configuration

```c
/*
 * SMPLRT_DIV register (0x19)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             0 | 0 | 0 | 0 | 0 | 1 | 1 | 1
 *             ^   ^   ^   ^   ^   ^   ^   ^
 *             |___|___|___|___|___|___|___| SMPLRT_DIV      
 */
cmd[0] = SMPLRT_DIV;
cmd[1] = 0x07;
```

The resulting sampling frequency is:

```
Sample Rate = 1kHz / (1 + 7) = 125 Hz
```

---

### Digital Low Pass Filter

```c
cmd[0] = CONFIG;
cmd[1] = 0x06;
```

Configures the **DLPF** to 5 Hz in order to reduce high-frequency noise.

---

### Accelerometer Configuration

```c
/*
 * ACCEL_CONFIG register (0x1C)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
 *             ^   ^   ^   ^   ^
 *             |   |   |   |   +-- AFS_SEL[0]
 *             |   |   |   +------ AFS_SEL[1]
 *             |   |   +---------- ZA_SELF_TEST
 *             |   +-------------- YA_SELF_TEST
 *             +------------------ XA_SELF_TEST
 *
 * AFS_SEL configuration:
 *   AFS_SEL | Full Scale | Hex
 *   --------+------------+-----
 *     0     | ±2g        | 0x00
 *     1     | ±4g        | 0x08
 *     2     | ±8g        | 0x10
 *     3     | ±16g       | 0x18
 */
cmd[0] = ACCEL_CONFIG;
cmd[1] = ACCEL_G_RANGE;
```

Sets the accelerometer full-scale range ±4g.

---

### Gyroscope Configuration

```c
/*
 * GYRO_CONFIG register (0x1B)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
 *             ^   ^   ^   ^   ^
 *             |   |   |   |   +-- FS_SEL[0]
 *             |   |   |   +------ FS_SEL[1]
 *             |   |   +---------- ZG_ST (Z Gyro Self-Test)
 *             |   +-------------- YG_ST (Y Gyro Self-Test)
 *             +------------------ XG_ST (X Gyro Self-Test)
 *
 * FS_SEL configuration:
 *   FS_SEL | Full Scale (°/s) | Hex  | Sensitivity (LSB/°/s)
 *   -------+------------------+------+---------------------
 *     0    | ±250             | 0x00 | 131.0
 *     1    | ±500             | 0x08 | 65.5
 *     2    | ±1000            | 0x10 | 32.8
 *     3    | ±2000            | 0x18 | 16.4
 */
cmd[0] = GYRO_CONFIG;
cmd[1] = GYRO_RANGE;
```

Sets the gyroscope full-scale range 2000.

---

### FIFO Reset and FIFO Enable

```c
/*
 * USER_CTRL register (0x6A)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             0 | 1 | 0 | 0 | 0 | 1 | 0 | 0
 *                 ^               ^
 *                 |               +-- FIFO_RESET (1 = reset FIFO buffer)
 *                 +-- FIFO_EN (1 = enable FIFO operations)
 *
 * Other bits:
 *   BIT 7: SIG_COND_RESET (signal path reset)
 *   BIT 5: I2C_MST_EN
 *   BIT 4: I2C_MST_RESET
 */
cmd[0] = USER_CTRL;
cmd[1] = 0x04;   // FIFO_RESET = 1
```

Resets the FIFO to discard old or corrupted data.

```c
cmd[1] = 0x40;   // FIFO_EN = 1
```

Enables the internal FIFO buffer.

This commands sequence is due to FIFO_*RESET reset the FIFO only if FIFO*_EN is set to 0. 

---

### FIFO Overflow Interrupt

```c
/*
 * INT_ENABLE register (0x38)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             0 | 0 | 0 | 1 | 0 | 0 | 0 | 0
 *                         ^
 *                         |
 *                         +-- FIFO_OFLOW_EN (1 = enable FIFO overflow interrupt)
 *
 */
cmd[0] = INT_ENABLE;
cmd[1] = 0x10;   // Enable FIFO overflow interrupt
```

Enables a FIFO buffer overflow to generate an interrupt.

---

### Enabling Sensors in FIFO

```c
/*
 * FIFO_EN register (0x23)
 *
 * Bit index:  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
 *             --------------------------------
 *             1 | 1 | 1 | 1 | 1 | 0 | 0 | 0
 *             ^   ^   ^   ^   ^
 *             |   |   |   |   +-- ACCEL_FIFO_EN (Accelerometer data to FIFO)
 *             |   |   |   +------ ZG_FIFO_EN (Z Gyro data to FIFO)
 *             |   |   +---------- YG_FIFO_EN (Y Gyro data to FIFO)
 *             |   +-------------- XG_FIFO_EN (X Gyro data to FIFO)
 *             +------------------ TEMP_FIFO_EN (Temperature data to FIFO)
 */
cmd[0] = FIFO_EN;
cmd[1] = 0xF8;   // Enable TEMP + ACCEL + GYRO XYZ in FIFO
```

Enables FIFO storage for accelerometer, gyroscope, and temperature sensor.

---

## FIFO Overflow Check
```c
bool mpu6050_check_overflow(void)
```

This function reads the `INT_STATUS` register and checks the overflow bit (`0x10`) with a logic AND.

If an overflow occurs:

1. FIFO is disabled
2. FIFO is reset
3. FIFO is re-enabled

   (see FIFO reset and FIFO enable)

This prevents corrupted or misaligned data reads.

---

## FIFO Size Reading
```c
int get_fifo_size (void)
```

This function reads the registers:
 
```c
#define FIFO_COUNT_H 0x72
#define FIFO_COUNT_L 0x73
```

Once read the registers we have to combine them in according to get the FIFO size. 

```c
fifo_size = (fifo_h << 8) | fifo_l;
```

Obtained `fifo_size`, we do some sanity checks:

* *FIFO empty*
* FIFO smaller than one sample
* FIFO size not multiple of sample size

Returns:

* valid FIFO size in bytes
* negative values in case of error

Where:
```c
`#define FIFO_SAMPLE_SIZE = 14`
```
---

## Raw Data Acquisition 
```c 
esp_err_t mpu6050_read_raw_data (Raw_Data_acc *raw_acc, Raw_Data_gyro *raw_gyro)
```
Data is read from the FIFO instead of live output registers, from the register:
`FIFO_R_W 0x74`.

FIFO packet layout (14 bytes):

| Bytes | Data                 |
| ----- | -------------------- |
| 0–5   | Accelerometer XYZ    |
| 6–7   | Temperature (unused) |
| 8–13  | Gyroscope XYZ        |

Each value is reconstructed as a `int16_t`.

---

## Conversion to Physical Units

### Accelerometer Conversion
```c
void mpu6050_convert_accel(Raw_Data_acc *raw_acc, ACC_Three_Axis_t *acc_data)

m/s² = (raw / ACCEL_SCALE) * GRAVITY - bias
```

Where:
```c
`#define ACCEL_SCALE 16384.0f`
`#define GRAVITY     9.8f`
```
---

### Gyroscope Conversion

```c
void mpu6050_convert_gyro  (Raw_Data_gyro *raw_gyro, GYRO_Three_Axis_t *gyro_data)

°/s = (raw / GYRO_SCALE) - bias
```

Bias values are subtracted to compensate static sensor offsets.

Where:
```c
#define GYRO_SCALE 131.0f
```
---

## Calibration

```c
void mpu6050_calibrate(float *accel_bias_out, float *gyro_bias_out)
```

This function compute the bias in relation with initial position of the mpu6050.

The vars `*_sum` are used to accumulate measurements across multiple samples to calculate the average, which allows us to estimate the sensor bias while reducing the influence of noise. In the case of the Z-axis accelerometer, gravity is subtracted to isolate the actual offset.

The AVG:
```c 
accel_bias_out[0] =  acc_sum.a_x_sum / target_samples;
accel_bias_out[1] =  acc_sum.a_y_sum / target_samples;
accel_bias_out[2] = (acc_sum.a_z_sum / target_samples) - GRAVITY;

gyro_bias_out[0] = gyro_sum.g_x_sum / target_samples;
gyro_bias_out[1] = gyro_sum.g_y_sum / target_samples;
gyro_bias_out[2] = gyro_sum.g_z_sum / target_samples;
```
rapresent the bias (the value which the sensor reads when it is still).

---
